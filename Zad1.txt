#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <stdbool.h>

#define MAX_SIZE 10

typedef struct Employee {
  char name[30];
  int id;
  float salary;
}
Employee;

typedef struct EmployeeList {
  Employee employees[MAX_SIZE];
  int current_size;
}
EmployeeList;

EmployeeList initEmployeeList();
bool addEmployeeToList(EmployeeList * empList, Employee employee);
void printEmployees(EmployeeList empList);
bool isEqual(struct Employee e1, struct Employee e2);
bool insertEmployeeAfter(EmployeeList * empList, Employee existingEmployee, Employee newEmployee);
bool insertEmployeeAtIndex(EmployeeList * empList, int index, Employee employee);
bool removeEmployeeAtIndex(EmployeeList * empList, int index);
bool removeEmployeeBehind(EmployeeList * empList, Employee existingEmployee);
void sortEmployeesBySalary(EmployeeList * empList);

int main() {
  EmployeeList empList = initEmployeeList();
  Employee emp1 = {
    "John",
    3453,
    3000.0
  };
  Employee emp2 = {
    "Maria",
    5412,
    1770.0
  };
  Employee emp3 = {
    "Kyle",
    4341,
    2500.0
  };
  Employee temp, temp2;
  int pos, ch;
  char g;

  addEmployeeToList( & empList, emp1);
  addEmployeeToList( & empList, emp2);
  addEmployeeToList( & empList, emp3);

  do {
    printf("\n Menu");
    printf("\n 1.Add employee \n 2.Print list \n 3.Insert employee on index \n 4.Insert employe after other employee in list \n 5.Remove employe from index \n 6.Remove employe behind other employee in list \n 7.Sort employees ascedning by salary \n 8.Exit \n");
    printf("\n Pick an option: ");
    scanf("%d", & ch);

    switch (ch) {
    case 1:
      fflush(stdin);
      printf("\n Insert employees ID: ");
      scanf("%d", & temp.id);
      printf("\n Insert employees name: ");
      scanf(" %[^\n]", temp.name);
      printf("\n Insert employees salary: ");
      scanf("%f", & temp.salary);
      addEmployeeToList( & empList, temp);
      break;

    case 2:
      printEmployees(empList);
      break;

    case 3:
      fflush(stdin);
      printf("\n Insert employees ID: ");
      scanf("%d", & temp.id);
      printf("\n Insert employees name: ");
      scanf(" %[^\n]", temp.name);
      printf("\n Insert employees salary: ");
      scanf("%f", & temp.salary);
      printf("\n Insert index on which you want to place new employee: ");
      scanf("%d", & pos);
      insertEmployeeAtIndex( & empList, pos, temp);
      break;

    case 4:
      fflush(stdin);
      printf("\n Insert new employees ID: ");
      scanf("%d", & temp.id);
      printf("\n Insert new employees name: ");
      scanf(" %[^\n]", temp.name);
      printf("\n Insert new employees salary: ");
      scanf("%f", & temp.salary);
      printf("\n Insert employee after which you want to place new employee: ");
      fflush(stdin);
      printf("\n Insert existing employees ID: ");
      scanf("%d", & temp2.id);
      printf("\n Insert existing employees name: ");
      scanf(" %[^\n]", temp2.name);
      printf("\n Insert existing employees salary: ");
      scanf("%f", & temp2.salary);

      insertEmployeeAfter( & empList, temp2, temp);
      break;

    case 5:
      printf("\n Insert index from which you want to delete employee: ");
      scanf("%d", & pos);
      removeEmployeeAtIndex( & empList, pos);
      break;

    case 6:
      printf("\n Insert employee behind which you want to delete employee: ");
      fflush(stdin);
      printf("\n Insert existing employees ID: ");
      scanf("%d", & temp.id);
      printf("\n Insert existing employees name: ");
      scanf(" %[^\n]", temp.name);
      printf("\n Insert existing employees salary: ");
      scanf("%f", & temp.salary);
      removeEmployeeBehind( & empList, temp);
      break;

    case 7:
      sortEmployeesBySalary( & empList);
      break;

    case 8:
      exit(1);
      break;

    default:
      printf("\n\n Wrong input");
      break;
    }
    printf("\n Do you want to continiue? y or n\n");
    scanf("\n%c", & g);
  }
  while (g == 'y' || g == 'Y');
  getch();

  return 0;
}

EmployeeList initEmployeeList() {
  EmployeeList empList;
  empList.current_size = 0;
  return empList;
}

bool addEmployeeToList(EmployeeList * empList, Employee employee) {
  if (empList -> current_size >= MAX_SIZE) {
    printf("Can not add employee, list is full\n");
    return false;
  }
  empList -> employees[empList -> current_size] = employee;
  empList -> current_size++;
  printf("New employee added successfully\n");
  return true;
}

void printEmployees(EmployeeList empList) {
  printf("Employees:\n");
  for (int i = 0; i < empList.current_size; i++) {
    printf("Name: %s\n", empList.employees[i].name);
    printf("ID: %d\n", empList.employees[i].id);
    printf("Salary: %f\n", empList.employees[i].salary);
    printf("\n");
  }
}

bool isEqual(Employee e1, Employee e2) {
  return strcmp(e1.name, e2.name) == 0 && e1.id == e2.id && e1.salary == e2.salary;
}

bool insertEmployeeAfter(EmployeeList * empList, Employee existingEmployee, Employee newEmployee) {
  if (empList -> current_size >= MAX_SIZE) {
    printf("Can not add employee, list is full\n");
    return false;
  }
  int index = -1;
  for (int i = 0; i < empList -> current_size; i++) {
    if (isEqual(existingEmployee, empList -> employees[i])) {
      index = i;
      break;
    }
  }
  if (index == -1) {
    printf("Can not add employee.Given employee does not exist in list\n");
    return false;
  }
  for (int i = empList -> current_size - 1; i > index; i--) {
    empList -> employees[i + 1] = empList -> employees[i];
  }
  empList -> employees[index + 1] = newEmployee;
  empList -> current_size++;
  printf("New employee inserted successfully\n");
  return true;
}

bool insertEmployeeAtIndex(EmployeeList * empList, int index, Employee employee) {
  if (empList -> current_size >= MAX_SIZE || index < 0 || index > empList -> current_size) {
    printf("Can not add employee.Given index is not valid\n");
    return false;
  }
  for (int i = empList -> current_size - 1; i >= index; i--) {
    empList -> employees[i + 1] = empList -> employees[i];
  }
  empList -> employees[index] = employee;
  empList -> current_size++;
  printf("New employee inserted successfully on index %d \n", index);
  return true;
}

bool removeEmployeeAtIndex(EmployeeList * empList, int index) {
  if (index < 0 || index >= empList -> current_size) {
    printf("Can not remove employee.Given index is not valid\n");
    return false;
  }
  for (int i = index; i < empList -> current_size - 1; i++) {
    empList -> employees[i] = empList -> employees[i + 1];
  }
  empList -> current_size--;
  printf("Employee removed successfully\n");
  return true;
}

bool removeEmployeeBehind(EmployeeList * empList, Employee existingEmployee) {
  int index = -1;
  for (int i = 0; i < empList -> current_size; i++) {
    if (isEqual(existingEmployee, empList -> employees[i])) {
      index = i;
      break;
    }
  }
  if (index == -1 || index + 1 == empList -> current_size) {
    printf("Can not remove employee.List is empty or employee does not exist\n");
    return false;
  }
  for (int i = index + 1; i < empList -> current_size - 1; i++) {
    empList -> employees[i] = empList -> employees[i + 1];
  }
  empList -> current_size--;
  printf("Employee removed successfully\n");
  return true;
}

void sortEmployeesBySalary(EmployeeList * empList) {
  for (int i = 0; i < empList -> current_size - 1; i++) {
    for (int j = 0; j < empList -> current_size - i - 1; j++) {
      if (empList -> employees[j].salary > empList -> employees[j + 1].salary) {
        Employee temp = empList -> employees[j];
        empList -> employees[j] = empList -> employees[j + 1];
        empList -> employees[j + 1] = temp;
      }
    }
  }
  printf("List sorted by salary successfully\n");
}